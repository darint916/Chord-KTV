## üìù Directory Explanation
![Build Status](https://github.com/darint916/Chord-KTV/actions/workflows/dotnet-build-run-check.yml/badge.svg) ![Style Police Status](https://github.com/darint916/Chord-KTV/actions/workflows/enforce-code-style.yml/badge.svg)


- **Controllers/** - Contains API controllers that handle incoming HTTP requests.
- **Data/** - Holds Repository facing files to directly query database, migrate database, and context.
- **Dtos/** - Houses Data Transfer Objects (DTOs) to structure API responses and also any other business logic models
- **Migrations/** - Stores database migration scripts for schema updates.
- **Models/** - Defines the application's core data models. (From Db)
- **Profiles/** - AutoMapper profiles for object transformations.
- **Properties/** - Holds project-level configuration settings.
- **Services/** - Contains business logic, API integrations (Interfaces), and service classes.
- **Utils/** - Any helper utilities or common functions used across the project.
- **bin/** & **obj/** - Generated by .NET for building and compiling the project.

---

## üí° Contribution Guidelines

1. Follow the existing folder structure when adding new files.
2. Keep controllers focused on request handling, moving logic to services.
3. Use DTOs for API responses to separate models from exposed data.
4. Always test your changes before making a pull request.

## PostgreSQL setup:

Make sure you have the PostgreSQL Docker image pulled, and that Docker Desktop is running.

Before building, run this command:
```bash
docker run -d -e POSTGRES_USER=<uname-for-postgres> -e POSTGRES_PASSWORD=<pwd-for-postgres> -p <free-port-number>:5432 postgres:15.4
```
This will start up a local containerized instance of PostgreSQL.

Create a secrets.json file with these contents:
```
{
    "ConnectionStrings:PostgreSql": "Host=localhost;Port=<port-no-for-postgres>;Database=postgres;Username=<uname-for-postgres>;Password=<pwd-for-postgres>"
}
```

After building, if you see an error like this:
```
fail: Microsoft.EntityFrameworkCore.Database.Command[20102]
      Failed executing DbCommand (17ms) [Parameters=[], CommandType='Text', CommandTimeout='5']
      SELECT "MigrationId", "ProductVersion"
      FROM "__EFMigrationsHistory"
      ORDER BY "MigrationId";
```
It's likely due to an issue with .NET EF core, this can be resolved by running
```bash
dotnet tool install --global dotnet-ef
```

This should allow you to build the project successfully using ```dotnet run```.


## Database model changes
If changes are made to any of the models, a migration is needed. Use PascalCase
```Powershell
dotnet ef migrations add <migration name>
dotnet ef database update
```

## API Documentation

#### ```GET /api/lyrics/lrclib/search```

Returns time-synced lyrics from LRCLIB. Attempts to retrieve both original and romanized lyrics if they exist.
Allows to perform either an exact search or a fuzzy search with the searchType query parameter (must be either "exact" or "fuzzy")
If searchType is "fuzzy", the API only looks at the qString parameter (due to LRCLIB API doing the same thing)
If searchType is "exact" the API looks at all fields except for qString.

Swagger spec:
![image](https://github.com/user-attachments/assets/758b8ed1-d081-4afd-a0e3-fd3e203197dd)

Note: need to be careful with the "fuzzy" search mode. Example bug case:
![image](https://github.com/user-attachments/assets/1a1aa934-4af8-44e0-9c27-4bd499a3f28a)
![image](https://github.com/user-attachments/assets/1401fab4-bd66-46df-9074-4b9e68409ffc)

The API returned the romanized lyrics for the Spanish version of the song. Since it only looks for the first entry in LRCLIB with time-synced lyrics, it has no way of validating whether those lyrics are actually the romanized version of the original song.

## License üìúüìù‚öñÔ∏è
This project is licensed under the [**MIT License**](LICENSE). üéºüéµüéß

If you have any questions, feel free to ask in the **issues** section! üöÄüé∂
