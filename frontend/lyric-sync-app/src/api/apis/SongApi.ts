/* tslint:disable */
/* eslint-disable */
/**
 * ChordKTV API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  FullSongRequestDto,
  FullSongResponseDto,
  GeniusHit,
  LrcLyricsDto,
  PlaylistDetailsDto,
  ProblemDetails,
  Song,
  SongDto,
  TranslationRequestDto,
  User,
} from '../models/index';
import {
    FullSongRequestDtoFromJSON,
    FullSongRequestDtoToJSON,
    FullSongResponseDtoFromJSON,
    FullSongResponseDtoToJSON,
    GeniusHitFromJSON,
    GeniusHitToJSON,
    LrcLyricsDtoFromJSON,
    LrcLyricsDtoToJSON,
    PlaylistDetailsDtoFromJSON,
    PlaylistDetailsDtoToJSON,
    ProblemDetailsFromJSON,
    ProblemDetailsToJSON,
    SongFromJSON,
    SongToJSON,
    SongDtoFromJSON,
    SongDtoToJSON,
    TranslationRequestDtoFromJSON,
    TranslationRequestDtoToJSON,
    UserFromJSON,
    UserToJSON,
} from '../models/index';

export interface ApiAlbumAlbumNameGetRequest {
    albumName: string;
    artist?: string;
}

export interface ApiDatabaseSongGetRequest {
    title: string;
    artist: string;
    albumName?: string;
}

export interface ApiDatabaseSongPostRequest {
    song?: Song;
}

export interface ApiDatabaseUsersEmailGetRequest {
    email: string;
}

export interface ApiLyricsLrcMatchGetRequest {
    title?: string;
    artist?: string;
    albumName?: string;
    duration?: number;
}

export interface ApiLyricsLrcTranslationPostRequest {
    translationRequestDto?: TranslationRequestDto;
}

export interface ApiSongsGeniusMatchBatchPostRequest {
    forceRefresh?: boolean;
    body?: any | null;
}

export interface ApiSongsGeniusMatchGetRequest {
    title?: string;
    artist?: string;
    lyrics?: string;
    forceRefresh?: boolean;
}

export interface ApiSongsGeniusSearchGetRequest {
    searchQuery: string;
}

export interface ApiSongsLrclibSearchGetRequest {
    searchQuery: string;
}

export interface ApiSongsMatchPostRequest {
    fullSongRequestDto?: FullSongRequestDto;
}

export interface ApiSongsSongIdVideoInstrumentalPutRequest {
    songId: string;
}

export interface ApiYoutubePlaylistsPlaylistIdGetRequest {
    playlistId: string;
    shuffle?: boolean;
}

/**
 * 
 */
export class SongApi extends runtime.BaseAPI {

    /**
     */
    async apiAlbumAlbumNameGetRaw(requestParameters: ApiAlbumAlbumNameGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SongDto>>> {
        if (requestParameters['albumName'] == null) {
            throw new runtime.RequiredError(
                'albumName',
                'Required parameter "albumName" was null or undefined when calling apiAlbumAlbumNameGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['artist'] != null) {
            queryParameters['artist'] = requestParameters['artist'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/api/album/{albumName}`.replace(`{${"albumName"}}`, encodeURIComponent(String(requestParameters['albumName']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SongDtoFromJSON));
    }

    /**
     */
    async apiAlbumAlbumNameGet(requestParameters: ApiAlbumAlbumNameGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SongDto>> {
        const response = await this.apiAlbumAlbumNameGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiDatabaseSongGetRaw(requestParameters: ApiDatabaseSongGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Song>> {
        if (requestParameters['title'] == null) {
            throw new runtime.RequiredError(
                'title',
                'Required parameter "title" was null or undefined when calling apiDatabaseSongGet().'
            );
        }

        if (requestParameters['artist'] == null) {
            throw new runtime.RequiredError(
                'artist',
                'Required parameter "artist" was null or undefined when calling apiDatabaseSongGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['title'] != null) {
            queryParameters['title'] = requestParameters['title'];
        }

        if (requestParameters['artist'] != null) {
            queryParameters['artist'] = requestParameters['artist'];
        }

        if (requestParameters['albumName'] != null) {
            queryParameters['albumName'] = requestParameters['albumName'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/api/database/song`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SongFromJSON(jsonValue));
    }

    /**
     */
    async apiDatabaseSongGet(requestParameters: ApiDatabaseSongGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Song> {
        const response = await this.apiDatabaseSongGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiDatabaseSongPostRaw(requestParameters: ApiDatabaseSongPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/api/database/song`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SongToJSON(requestParameters['song']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiDatabaseSongPost(requestParameters: ApiDatabaseSongPostRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiDatabaseSongPostRaw(requestParameters, initOverrides);
    }

    /**
     */
    async apiDatabaseUsersEmailGetRaw(requestParameters: ApiDatabaseUsersEmailGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<User>> {
        if (requestParameters['email'] == null) {
            throw new runtime.RequiredError(
                'email',
                'Required parameter "email" was null or undefined when calling apiDatabaseUsersEmailGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/api/database/users/{email}`.replace(`{${"email"}}`, encodeURIComponent(String(requestParameters['email']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
    }

    /**
     */
    async apiDatabaseUsersEmailGet(requestParameters: ApiDatabaseUsersEmailGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<User> {
        const response = await this.apiDatabaseUsersEmailGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiHealthGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/api/health`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     */
    async apiHealthGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.apiHealthGetRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async apiLyricsLrcMatchGetRaw(requestParameters: ApiLyricsLrcMatchGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LrcLyricsDto>> {
        const queryParameters: any = {};

        if (requestParameters['title'] != null) {
            queryParameters['title'] = requestParameters['title'];
        }

        if (requestParameters['artist'] != null) {
            queryParameters['artist'] = requestParameters['artist'];
        }

        if (requestParameters['albumName'] != null) {
            queryParameters['albumName'] = requestParameters['albumName'];
        }

        if (requestParameters['duration'] != null) {
            queryParameters['duration'] = requestParameters['duration'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/api/lyrics/lrc/match`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LrcLyricsDtoFromJSON(jsonValue));
    }

    /**
     */
    async apiLyricsLrcMatchGet(requestParameters: ApiLyricsLrcMatchGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LrcLyricsDto> {
        const response = await this.apiLyricsLrcMatchGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiLyricsLrcTranslationPostRaw(requestParameters: ApiLyricsLrcTranslationPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LrcLyricsDto>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/api/lyrics/lrc/translation`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TranslationRequestDtoToJSON(requestParameters['translationRequestDto']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LrcLyricsDtoFromJSON(jsonValue));
    }

    /**
     */
    async apiLyricsLrcTranslationPost(requestParameters: ApiLyricsLrcTranslationPostRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LrcLyricsDto> {
        const response = await this.apiLyricsLrcTranslationPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiSongsGeniusMatchBatchPostRaw(requestParameters: ApiSongsGeniusMatchBatchPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SongDto>>> {
        const queryParameters: any = {};

        if (requestParameters['forceRefresh'] != null) {
            queryParameters['forceRefresh'] = requestParameters['forceRefresh'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/api/songs/genius/match/batch`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SongDtoFromJSON));
    }

    /**
     */
    async apiSongsGeniusMatchBatchPost(requestParameters: ApiSongsGeniusMatchBatchPostRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SongDto>> {
        const response = await this.apiSongsGeniusMatchBatchPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiSongsGeniusMatchGetRaw(requestParameters: ApiSongsGeniusMatchGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SongDto>> {
        const queryParameters: any = {};

        if (requestParameters['title'] != null) {
            queryParameters['title'] = requestParameters['title'];
        }

        if (requestParameters['artist'] != null) {
            queryParameters['artist'] = requestParameters['artist'];
        }

        if (requestParameters['lyrics'] != null) {
            queryParameters['lyrics'] = requestParameters['lyrics'];
        }

        if (requestParameters['forceRefresh'] != null) {
            queryParameters['forceRefresh'] = requestParameters['forceRefresh'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/api/songs/genius/match`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SongDtoFromJSON(jsonValue));
    }

    /**
     */
    async apiSongsGeniusMatchGet(requestParameters: ApiSongsGeniusMatchGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SongDto> {
        const response = await this.apiSongsGeniusMatchGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiSongsGeniusSearchGetRaw(requestParameters: ApiSongsGeniusSearchGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<GeniusHit>>> {
        if (requestParameters['searchQuery'] == null) {
            throw new runtime.RequiredError(
                'searchQuery',
                'Required parameter "searchQuery" was null or undefined when calling apiSongsGeniusSearchGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['searchQuery'] != null) {
            queryParameters['searchQuery'] = requestParameters['searchQuery'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/api/songs/genius/search`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(GeniusHitFromJSON));
    }

    /**
     */
    async apiSongsGeniusSearchGet(requestParameters: ApiSongsGeniusSearchGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<GeniusHit>> {
        const response = await this.apiSongsGeniusSearchGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiSongsLrclibSearchGetRaw(requestParameters: ApiSongsLrclibSearchGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<LrcLyricsDto>>> {
        if (requestParameters['searchQuery'] == null) {
            throw new runtime.RequiredError(
                'searchQuery',
                'Required parameter "searchQuery" was null or undefined when calling apiSongsLrclibSearchGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['searchQuery'] != null) {
            queryParameters['searchQuery'] = requestParameters['searchQuery'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/api/songs/lrclib/search`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(LrcLyricsDtoFromJSON));
    }

    /**
     */
    async apiSongsLrclibSearchGet(requestParameters: ApiSongsLrclibSearchGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<LrcLyricsDto>> {
        const response = await this.apiSongsLrclibSearchGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiSongsMatchPostRaw(requestParameters: ApiSongsMatchPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FullSongResponseDto>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/api/songs/match`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FullSongRequestDtoToJSON(requestParameters['fullSongRequestDto']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullSongResponseDtoFromJSON(jsonValue));
    }

    /**
     */
    async apiSongsMatchPost(requestParameters: ApiSongsMatchPostRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FullSongResponseDto> {
        const response = await this.apiSongsMatchPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiSongsSongIdVideoInstrumentalPutRaw(requestParameters: ApiSongsSongIdVideoInstrumentalPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['songId'] == null) {
            throw new runtime.RequiredError(
                'songId',
                'Required parameter "songId" was null or undefined when calling apiSongsSongIdVideoInstrumentalPut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/api/songs/{songId}/video/instrumental`.replace(`{${"songId"}}`, encodeURIComponent(String(requestParameters['songId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     */
    async apiSongsSongIdVideoInstrumentalPut(requestParameters: ApiSongsSongIdVideoInstrumentalPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.apiSongsSongIdVideoInstrumentalPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiYoutubePlaylistsPlaylistIdGetRaw(requestParameters: ApiYoutubePlaylistsPlaylistIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PlaylistDetailsDto>> {
        if (requestParameters['playlistId'] == null) {
            throw new runtime.RequiredError(
                'playlistId',
                'Required parameter "playlistId" was null or undefined when calling apiYoutubePlaylistsPlaylistIdGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['shuffle'] != null) {
            queryParameters['shuffle'] = requestParameters['shuffle'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/api/youtube/playlists/{playlistId}`.replace(`{${"playlistId"}}`, encodeURIComponent(String(requestParameters['playlistId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PlaylistDetailsDtoFromJSON(jsonValue));
    }

    /**
     */
    async apiYoutubePlaylistsPlaylistIdGet(requestParameters: ApiYoutubePlaylistsPlaylistIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PlaylistDetailsDto> {
        const response = await this.apiYoutubePlaylistsPlaylistIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
